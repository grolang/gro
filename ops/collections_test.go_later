// Copyright 2017 The Gro Authors. All rights reserved.
// Use of this source code is governed by the same BSD-style
// license as Go that can be found in the LICENSE file.

/*
contents:
func TestAssigns(t *testing.T){
func TestSlices(t *testing.T){
func TestMaps(t *testing.T){
func TestIncrDecr (t *testing.T){
func TestSliceIndexing(t *testing.T){
func TestMapIndexing(t *testing.T){
*/
package ops_test

import (
	"fmt"
	"testing"

	ts "github.com/grolang/gro/assert"
	tp "github.com/grolang/gro/ops"
	u8 "github.com/grolang/gro/utf88"
)

//================================================================================
func TestAssigns(t *testing.T) {
	ts.LogAsserts("Assigns", t, func(tt *ts.T) {

		//Int
		// a= 28
		{
			var a interface{}
			_ = *tp.Assign(&a, 28)
			tt.AssertEqual(fmt.Sprint(a), "28")
		}

		// a:= 27; a= 28
		{
			a := tp.Identity(27)
			a = *tp.Assign(&a, 28)
			tt.AssertEqual(fmt.Sprint(a), "28")
		}

		// a, b= 28, 38
		{
			a := tp.Identity(27)
			b := tp.Identity(37)
			_, _ = *tp.Assign(&a, 28), *tp.Assign(&b, 38)
			tt.AssertEqual(fmt.Sprint(a), "28")
			tt.AssertEqual(fmt.Sprint(b), "38")
		}

		// a= b= 7
		{
			a := tp.Identity(13)
			b := tp.Identity(27)
			a = *tp.Assign(&a, *tp.Assign(&b, 7)) //right-assoc
			tt.AssertEqual(fmt.Sprint(a), "7")
			tt.AssertEqual(fmt.Sprint(b), "7")
		}

	})
}

//================================================================================
func TestSlices(t *testing.T) {
	ts.LogAsserts("Slices", t, func(tt *ts.T) {

		//NewSlice
		{
			tt.AssertEqual(fmt.Sprint(tp.NewSlice(2)), "[<nil> <nil>]")
			tt.AssertEqual(fmt.Sprint(tp.NewSlice(0)), "[]")
		}

		//InitSlice
		//Slice: a:= []any{'a', 'b', 'c'}
		//Slice: a= []any{'d', 'e'}
		{
			a := tp.InitSlice('a', 'b', 'c')
			_ = *tp.Assign(&a, tp.InitSlice(u8.Codepoint('d'), u8.Codepoint('e')))
			tt.AssertEqual(fmt.Sprint(a), "['d' 'e']")
		}

		//moot
		{
			a := tp.InitSlice('a', 'b', 'c')
			a = *tp.Assign(&a, tp.InitSlice(u8.Codepoint('d'), u8.Codepoint('e')))
			tt.AssertEqual(fmt.Sprint(a), "['d' 'e']")
		}

		//Slice: a:= []any{'a', 'b', 'c'}
		//Slice: a= []any{'d', 'e'}
		{
			a := tp.InitSlice('a', 'b', 'c')
			b := tp.InitSlice()
			_ = *tp.Assign(&b, *tp.Assign(&a, tp.InitSlice(u8.Codepoint('d'), u8.Codepoint('e'))))
			tt.AssertEqual(fmt.Sprint(a), "['d' 'e']")
			tt.AssertEqual(fmt.Sprint(b), "['d' 'e']")
		}

		//Slice: Copy
		{
			s1 := tp.InitSlice(1, 3, 5, 7)
			s2 := tp.Copy(s1)
			s3 := s1
			tt.AssertEqual(fmt.Sprint(s2), "[1 3 5 7]")

			s1 = tp.Plus(s3, "Booya")
			tt.AssertEqual(fmt.Sprint(s1), "[1 3 5 7 Booya]")
			tt.AssertEqual(fmt.Sprint(s2), "[1 3 5 7]")
			tt.AssertEqual(fmt.Sprint(s3), "[1 3 5 7]") //s3 copied len from s1 but points to same values

			_ = *tp.SetIndex(&s2, 2, "Five")
			tt.AssertEqual(fmt.Sprint(s2), "[1 3 Five 7]") //s2 copied values from s1
			tt.AssertEqual(fmt.Sprint(s3), "[1 3 5 7]")
		}

		//Slice: a:= []any{1,3,5,7}
		//Slice: a + "baa" + 99 + true
		//Slice: Len
		{
			a := tp.InitSlice(1, 3, 5, 7)
			tt.AssertEqual(fmt.Sprint(a), "[1 3 5 7]")
			tt.AssertEqual(fmt.Sprint(tp.Len(a)), "4")
			tt.AssertEqual(fmt.Sprint(tp.Plus(tp.Plus(tp.Plus(a, "baa"), 99), true)), "[1 3 5 7 baa 99 true]")
			tt.AssertEqual(fmt.Sprint(a), "[1 3 5 7]") //still the same!

			b := tp.Plus(tp.Plus(tp.Plus(a, "baa"), 99), true)
			c := tp.Plus(tp.Plus(a, ' '), 987)
			tt.AssertEqual(fmt.Sprint(b), "[1 3 5 7 baa 99 true]")
			tt.AssertEqual(fmt.Sprint(c), "[1 3 5 7 32 987]")
		}

		//TODO: Slice: Minus ###############################

		//Slice: a += 9
		{
			a := tp.InitSlice(1, 3, 5, 7)
			tt.AssertEqual(fmt.Sprint(a), "[1 3 5 7]")
			tt.AssertEqual(fmt.Sprint(*tp.PlusAssign(&a, 9)), "[1 3 5 7 9]")
		}

		//Slice: a += 99 += 9
		{
			a := tp.InitSlice(1, 3, 5, 7)
			tt.AssertEqual(fmt.Sprint(a), "[1 3 5 7]")
			tt.AssertEqual(fmt.Sprint(*tp.PlusAssign(&*tp.PlusAssign(&a, 99), 9)), "[1 3 5 7 99 9]")
		}

		//Slice: PlusAssign
		//Slice: a:= []any{1,3,5,7}
		//Slice: a += "baa" += 99 += true
		//Slice: b:= a += "abba" += 911 += false
		{
			a := tp.InitSlice(1, 3, 5, 7)
			tt.AssertEqual(fmt.Sprint(a), "[1 3 5 7]")
			tt.AssertEqual(fmt.Sprint(tp.Len(a)), "4")
			tt.AssertEqual(fmt.Sprint(*tp.PlusAssign(&*tp.PlusAssign(&*tp.PlusAssign(&a, "baa"), 99), true)), "[1 3 5 7 baa 99 true]")
			tt.AssertEqual(fmt.Sprint(a), "[1 3 5 7 baa 99 true]") //updated!

			b := *tp.PlusAssign(&*tp.PlusAssign(&*tp.PlusAssign(&a, "abba"), 911), false)
			tt.AssertEqual(fmt.Sprint(a), "[1 3 5 7 baa 99 true abba 911 false]")
			tt.AssertEqual(fmt.Sprint(b), "[1 3 5 7 baa 99 true abba 911 false]")

			c := *tp.PlusAssign(&*tp.PlusAssign(&a, ' '), 987)
			tt.AssertEqual(fmt.Sprint(a), "[1 3 5 7 baa 99 true abba 911 false 32 987]")
			tt.AssertEqual(fmt.Sprint(c), "[1 3 5 7 baa 99 true abba 911 false 32 987]")
		}

		//TODO: Slice: MinusAssign ###############################

	})
}

//================================================================================
func TestMaps(t *testing.T) {
	ts.LogAsserts("Maps", t, func(tt *ts.T) {

		//TODO: NewMap ###############################

		//InitMap
		//Map: a:= map[any]any{7:"NEW", 10:"Yeh"}
		//Map: a= map[any]any{7:"old", 9:"Measles"}
		{
			a := tp.InitMap(tp.InitSlice(7, "NEW"), tp.InitSlice(10, "Yeh"))
			_ = *tp.Assign(&a, tp.InitMap(tp.InitSlice(7, "old"), tp.InitSlice(9, "Measles")))
			tt.AssertEqual(a, tp.InitMap(tp.InitSlice(7, "old"), tp.InitSlice(9, "Measles")))
		}

		//moot
		{
			a := tp.InitMap(tp.InitSlice(7, "NEW"), tp.InitSlice(10, "Yeh"))
			a = *tp.Assign(&a, tp.InitMap(tp.InitSlice(7, "old"), tp.InitSlice(9, "Measles")))
			tt.AssertEqual(a, tp.InitMap(tp.InitSlice(7, "old"), tp.InitSlice(9, "Measles")))
		}

		//Map: a:= map[any]any{7:"NEW", 10:"Yeh"}
		//Map: b= a= map[any]any{7:"old", 9:"Measles"}
		{
			a := tp.InitMap(tp.InitSlice(7, "NEW"), tp.InitSlice(10, "Yeh"))
			b := tp.InitMap()
			_ = *tp.Assign(&b, *tp.Assign(&a, tp.InitMap(tp.InitSlice(7, "old"), tp.InitSlice(9, "Measles"))))
			tt.AssertEqual(a, tp.InitMap(tp.InitSlice(7, "old"), tp.InitSlice(9, "Measles")))
			tt.AssertEqual(b, tp.InitMap(tp.InitSlice(7, "old"), tp.InitSlice(9, "Measles")))
		}

		//Map: Copy
		{
			m1 := tp.InitMap(tp.InitSlice(7, "Hey!"), tp.InitSlice(9, "Bye?"), tp.InitSlice(10, "Yeh"))
			m2 := tp.Copy(m1)
			m3 := m1
			tt.AssertEqual(m1, tp.InitMap(tp.InitSlice(7, "Hey!"), tp.InitSlice(9, "Bye?"), tp.InitSlice(10, "Yeh")))
			tt.AssertEqual(m2, tp.InitMap(tp.InitSlice(7, "Hey!"), tp.InitSlice(9, "Bye?"), tp.InitSlice(10, "Yeh")))
			tt.AssertEqual(m3, tp.InitMap(tp.InitSlice(7, "Hey!"), tp.InitSlice(9, "Bye?"), tp.InitSlice(10, "Yeh")))

			m4 := *tp.MinusAssign(&m1, 9)
			tt.AssertEqual(m1, tp.InitMap(tp.InitSlice(7, "Hey!"), tp.InitSlice(10, "Yeh")))
			tt.AssertEqual(m2, tp.InitMap(tp.InitSlice(7, "Hey!"), tp.InitSlice(9, "Bye?"), tp.InitSlice(10, "Yeh")))
			tt.AssertEqual(m3, tp.InitMap(tp.InitSlice(7, "Hey!"), tp.InitSlice(10, "Yeh")))
			tt.AssertEqual(m4, tp.InitMap(tp.InitSlice(7, "Hey!"), tp.InitSlice(10, "Yeh")))
		}

		//TODO: Map: Plus, Minus ###############################

		//Map: PlusAssign, Len
		{
			m1 := tp.NewMap()
			tt.AssertEqual(fmt.Sprint(m1), "map[]")

			m2 := *tp.PlusAssign(&m1, tp.MapEntry{7, "Hey!"})
			tt.AssertEqual(fmt.Sprint(m1), "map[7:Hey!]")
			tt.AssertEqual(fmt.Sprint(m2), "map[7:Hey!]")

			m3 := *tp.PlusAssign(&m1, tp.MapEntry{9, "Bye?"})
			tt.AssertEqual(m1, tp.InitMap(tp.InitSlice(7, "Hey!"), tp.InitSlice(9, "Bye?")))
			tt.AssertEqual(m3, tp.InitMap(tp.InitSlice(7, "Hey!"), tp.InitSlice(9, "Bye?")))
			tt.AssertEqual(tp.Len(m1), 2)
			tt.AssertEqual(*tp.GetIndex(&m1, 9), "Bye?")

			m4 := *tp.PlusAssign(&m1, tp.MapEntry{10, "Yeh"})
			tt.AssertEqual(m1, tp.InitMap(tp.InitSlice(7, "Hey!"), tp.InitSlice(9, "Bye?"), tp.InitSlice(10, "Yeh")))
			tt.AssertEqual(m2, tp.InitMap(tp.InitSlice(7, "Hey!"), tp.InitSlice(9, "Bye?"), tp.InitSlice(10, "Yeh")))
			tt.AssertEqual(m3, tp.InitMap(tp.InitSlice(7, "Hey!"), tp.InitSlice(9, "Bye?"), tp.InitSlice(10, "Yeh")))
			tt.AssertEqual(m4, tp.InitMap(tp.InitSlice(7, "Hey!"), tp.InitSlice(9, "Bye?"), tp.InitSlice(10, "Yeh")))

			m5 := *tp.PlusAssign(&m1, tp.MapEntry{7, "NEW"})
			tt.AssertEqual(m1, tp.InitMap(tp.InitSlice(7, "NEW"), tp.InitSlice(9, "Bye?"), tp.InitSlice(10, "Yeh")))
			tt.AssertEqual(m2, tp.InitMap(tp.InitSlice(7, "NEW"), tp.InitSlice(9, "Bye?"), tp.InitSlice(10, "Yeh")))
			tt.AssertEqual(m3, tp.InitMap(tp.InitSlice(7, "NEW"), tp.InitSlice(9, "Bye?"), tp.InitSlice(10, "Yeh")))
			tt.AssertEqual(m4, tp.InitMap(tp.InitSlice(7, "NEW"), tp.InitSlice(9, "Bye?"), tp.InitSlice(10, "Yeh")))
			tt.AssertEqual(m5, tp.InitMap(tp.InitSlice(7, "NEW"), tp.InitSlice(9, "Bye?"), tp.InitSlice(10, "Yeh")))
		}

		//Map: MinusAssign
		{
			m1 := tp.InitMap(tp.InitSlice(7, "Hey!"), tp.InitSlice(9, "Bye?"), tp.InitSlice(10, "Yeh"))
			tt.AssertEqual(m1, tp.InitMap(tp.InitSlice(7, "Hey!"), tp.InitSlice(9, "Bye?"), tp.InitSlice(10, "Yeh")))

			m2 := *tp.MinusAssign(&m1, 9)
			tt.AssertEqual(m1, tp.InitMap(tp.InitSlice(7, "Hey!"), tp.InitSlice(10, "Yeh")))
			tt.AssertEqual(m2, tp.InitMap(tp.InitSlice(7, "Hey!"), tp.InitSlice(10, "Yeh")))
		}

	})
}

//================================================================================
func TestIncrDecr(t *testing.T) {
	ts.LogAsserts("IncrDecr", t, func(tt *ts.T) {

		// a++ a--
		{
			a := tp.Identity(7)
			tt.AssertEqual(a, tp.Int(7))
			tt.AssertEqual(tp.Incr(&a), tp.Int(7))
			tt.AssertEqual(a, tp.Int(8))
			tt.AssertEqual(tp.Decr(&a), tp.Int(8))
			tt.AssertEqual(a, tp.Int(7))
		}

		// c= d++
		{
			c := tp.Identity(nil)
			d := tp.Identity(tp.Int(7))
			tt.AssertEqual(d, tp.Int(7))
			_ = *tp.Assign(&c, tp.Incr(&d))
			tt.AssertEqual(c, tp.Int(7))
			tt.AssertEqual(d, tp.Int(8))
		}

	})
}

//================================================================================
func TestSliceIndexing(t *testing.T) {
	ts.LogAsserts("SliceIndexing", t, func(tt *ts.T) {

		// _=a[2] and a[2]="Hey!" for slice
		{
			va := tp.Identity([]interface{}{95, 96, 97, 98, 99})
			a := *tp.GetIndex(&va, 2)
			tt.AssertEqual(a, tp.Int(97))
			tp.SetIndex(&va, 2, "Hey!")
			tt.AssertEqual(va, tp.Slice{tp.Int(95), tp.Int(96), u8.Text("Hey!"), tp.Int(98), tp.Int(99)})
		}

		// b[2]= 'z'
		{
			b := tp.Identity([]interface{}{tp.Runex('f'), tp.Runex('g'), tp.Runex('h'), 'i'})
			_ = *tp.SetIndex(&b, 2, u8.Codepoint('z'))
			tt.AssertEqual(b.(tp.Slice)[2], u8.Codepoint('z'))
			tt.AssertEqual(b, tp.Slice{u8.Codepoint('f'), u8.Codepoint('g'), u8.Codepoint('z'), tp.Int('i')})
		}

		// moot of b[2]='z'
		{
			b := tp.Identity([]interface{}{tp.Runex('f'), tp.Runex('g'), tp.Runex('h'), 'i'})
			_ = *tp.Assign(&*tp.GetIndex(&b, 2), u8.Codepoint('z'))
			tt.AssertEqual(b.(tp.Slice)[2], u8.Codepoint('z'))
			tt.AssertEqual(b, tp.Slice{u8.Codepoint('f'), u8.Codepoint('g'), u8.Codepoint('z'), tp.Int('i')})
		}

		// c[2]= c[2]+61
		{
			c := tp.Identity([]interface{}{10, 11, 12, 13, 14})
			_ = *tp.SetIndex(&c, 2, tp.Plus(*tp.GetIndex(&c, 2), 61))

			tt.AssertEqual(c.(tp.Slice)[2], tp.Int(73))
			tt.AssertEqual(c, tp.Slice{tp.Int(10), tp.Int(11), tp.Int(73), tp.Int(13), tp.Int(14)})
		}

		// a= b[2]= 7
		{
			var a interface{}
			b := tp.Identity([]interface{}{10, 11, 12, 13, 14})
			_ = *tp.Assign(&a, *tp.SetIndex(&b, 2, 7))

			tt.AssertEqual(a, tp.Int(7))
			tt.AssertEqual(b.(tp.Slice)[2], tp.Int(7))
			tt.AssertEqual(b, tp.Slice{tp.Int(10), tp.Int(11), tp.Int(7), tp.Int(13), tp.Int(14)})
		}

		// a[1]= b[2]= 7
		{
			a := tp.Identity([]interface{}{80, 81, 82, 83})
			b := tp.Identity([]interface{}{10, 11, 12, 13, 14})
			_ = *tp.SetIndex(&a, 1, *tp.SetIndex(&b, 2, 7))

			tt.AssertEqual(a.(tp.Slice)[1], tp.Int(7))
			tt.AssertEqual(a, tp.Slice{tp.Int(80), tp.Int(7), tp.Int(82), tp.Int(83)})
			tt.AssertEqual(b.(tp.Slice)[2], tp.Int(7))
			tt.AssertEqual(b, tp.Slice{tp.Int(10), tp.Int(11), tp.Int(7), tp.Int(13), tp.Int(14)})
		}

		// c[2]++
		{
			c := tp.Identity([]interface{}{10, 11, 12, 13, 14})
			_ = tp.Incr(&*tp.GetIndex(&c, 2))

			tt.AssertEqual(c.(tp.Slice)[2], tp.Int(13))
			tt.AssertEqual(c, tp.Slice{tp.Int(10), tp.Int(11), tp.Int(13), tp.Int(13), tp.Int(14)})
		}

		// c= d[2]++
		{
			var c interface{}
			d := tp.Identity([]interface{}{10, 11, 12, 13, 14})
			_ = *tp.Assign(&c, tp.Incr(&*tp.GetIndex(&d, 2)))

			tt.AssertEqual(c, tp.Int(12))
			tt.AssertEqual(d.(tp.Slice)[2], tp.Int(13))
			tt.AssertEqual(d, tp.Slice{tp.Int(10), tp.Int(11), tp.Int(13), tp.Int(13), tp.Int(14)})
		}

	})
}

//================================================================================
func TestMapIndexing(t *testing.T) {
	ts.LogAsserts("MapIndexing", t, func(tt *ts.T) {

		// _=b['c'] and b['c']="Bye?"
		{
			vb := tp.Identity(map[interface{}]interface{}{tp.Runex('a'): 75, tp.Runex('b'): 76, tp.Runex('c'): 77, tp.Runex('d'): 78, tp.Runex('e'): 79})
			b := *tp.GetIndex(&vb, u8.Codepoint('c'))
			tt.AssertEqual(b, tp.Int(77))
			tp.SetIndex(&vb, u8.Codepoint('c'), "Bye?")
			tt.AssertEqual(vb, map[interface{}]interface{}{
				u8.Codepoint('a'): tp.Int(75),
				u8.Codepoint('b'): tp.Int(76),
				u8.Codepoint('c'): u8.Text("Bye?"),
				u8.Codepoint('d'): tp.Int(78),
				u8.Codepoint('e'): tp.Int(79)})
		}

		//TODO: Map: GetIndex, SetIndex ###############################

	})
}

//================================================================================
